// Klar Standard Library - String
//
// The String type represents a growable, UTF-8 encoded string.

/// A UTF-8 encoded, growable string.
pub struct String {
    data: [u8],
    len: usize
}

impl String {
    /// Creates a new empty String.
    pub fn new() -> String {
        return String { data: [], len: 0 }
    }

    /// Creates a new String with the given capacity.
    pub fn with_capacity(capacity: usize) -> String {
        return String { data: [], len: 0 }
    }

    /// Creates a String from a string literal.
    pub fn from(s: str) -> String {
        return String { data: s.as_bytes(), len: s.len() }
    }

    /// Returns the length of the string in bytes.
    pub fn len(self) -> usize {
        return self.len
    }

    /// Returns true if the string is empty.
    pub fn is_empty(self) -> bool {
        return self.len == 0
    }

    /// Returns the string as a str slice.
    pub fn as_str(self) -> str {
        return self.data.as_str()
    }

    /// Returns a byte slice of the string contents.
    pub fn as_bytes(self) -> [u8] {
        return self.data
    }

    /// Appends a string slice to this String.
    pub fn push_str(self, s: str) {
        for byte in s.as_bytes() {
            self.data.push(byte)
        }
        self.len = self.len + s.len()
    }

    /// Appends a character to this String.
    pub fn push(self, ch: char) {
        let bytes: [u8] = ch.encode_utf8()
        for byte in bytes {
            self.data.push(byte)
        }
        self.len = self.len + bytes.len()
    }

    /// Removes the last character from the string and returns it.
    pub fn pop(self) -> Option[char] {
        if self.is_empty() {
            return None
        } else {
            let ch: Option[char] = self.chars().last()
            if ch.is_some() {
                let char_len: usize = ch.unwrap().len_utf8()
                self.len = self.len - char_len
                self.data.truncate(self.len)
            }
            return ch
        }
    }

    /// Clears the string, removing all contents.
    pub fn clear(self) {
        self.data.clear()
        self.len = 0
    }

    /// Concatenates two strings.
    pub fn concat(self, other: String) -> String {
        var result: String = self.clone()
        result.push_str(other.as_str())
        return result
    }

    /// Returns true if the string contains the given substring.
    pub fn contains(self, pattern: str) -> bool {
        return self.find(pattern).is_some()
    }

    /// Returns true if the string starts with the given prefix.
    pub fn starts_with(self, prefix: str) -> bool {
        if prefix.len() > self.len {
            return false
        } else {
            return self.as_str()[0..prefix.len()] == prefix
        }
    }

    /// Returns true if the string ends with the given suffix.
    pub fn ends_with(self, suffix: str) -> bool {
        if suffix.len() > self.len {
            return false
        } else {
            return self.as_str()[(self.len - suffix.len())..self.len] == suffix
        }
    }

    /// Returns the index of the first occurrence of the pattern, or None.
    pub fn find(self, pattern: str) -> Option[usize] {
        if pattern.is_empty() {
            return Some(0)
        }
        if pattern.len() > self.len {
            return None
        }
        for i in 0..(self.len - pattern.len() + 1) {
            if self.as_str()[i..(i + pattern.len())] == pattern {
                return Some(i)
            }
        }
        return None
    }

    /// Replaces all occurrences of a pattern with another string.
    pub fn replace(self, from: str, to: str) -> String {
        var result: String = String.new()
        var i: usize = 0
        while i < self.len {
            if i + from.len() <= self.len and self.as_str()[i..(i + from.len())] == from {
                result.push_str(to)
                i = i + from.len()
            } else {
                result.push(self.as_str()[i])
                i = i + 1
            }
        }
        return result
    }

    /// Returns a substring of this string.
    pub fn substring(self, start: usize, end: usize) -> String {
        if start > end or end > self.len {
            return String.new()
        } else {
            return String.from(self.as_str()[start..end])
        }
    }

    /// Returns a string slice with leading and trailing whitespace removed.
    pub fn trim(self) -> str {
        return self.trim_start().trim_end()
    }

    /// Returns a string slice with leading whitespace removed.
    pub fn trim_start(self) -> str {
        var start: usize = 0
        while start < self.len and self.as_str()[start].is_whitespace() {
            start = start + 1
        }
        return self.as_str()[start..self.len]
    }

    /// Returns a string slice with trailing whitespace removed.
    pub fn trim_end(self) -> str {
        var end: usize = self.len
        while end > 0 and self.as_str()[end - 1].is_whitespace() {
            end = end - 1
        }
        return self.as_str()[0..end]
    }

    /// Converts the string to uppercase.
    pub fn to_uppercase(self) -> String {
        var result: String = String.with_capacity(self.len)
        for ch in self.chars() {
            result.push(ch.to_uppercase())
        }
        return result
    }

    /// Converts the string to lowercase.
    pub fn to_lowercase(self) -> String {
        var result: String = String.with_capacity(self.len)
        for ch in self.chars() {
            result.push(ch.to_lowercase())
        }
        return result
    }

    /// Splits the string by the given delimiter.
    pub fn split(self, delimiter: str) -> List[String] {
        var result: List[String] = List.new()
        var start: usize = 0
        var i: usize = 0

        while i <= self.len - delimiter.len() {
            if self.as_str()[i..(i + delimiter.len())] == delimiter {
                result.push(self.substring(start, i))
                start = i + delimiter.len()
                i = start
            } else {
                i = i + 1
            }
        }
        result.push(self.substring(start, self.len))
        return result
    }

    /// Splits the string by whitespace.
    pub fn split_whitespace(self) -> List[String] {
        var result: List[String] = List.new()
        var current: String = String.new()

        for ch in self.chars() {
            if ch.is_whitespace() {
                if not current.is_empty() {
                    result.push(current)
                    current = String.new()
                }
            } else {
                current.push(ch)
            }
        }
        if not current.is_empty() {
            result.push(current)
        }
        return result
    }

    /// Returns an iterator over the characters of the string.
    pub fn chars(self) -> Chars {
        return Chars { data: self.as_str(), pos: 0 }
    }

    /// Returns an iterator over the bytes of the string.
    pub fn bytes(self) -> Bytes {
        return Bytes { data: self.data, pos: 0 }
    }

    /// Returns an iterator over the lines of the string.
    pub fn lines(self) -> Lines {
        return Lines { remaining: self.as_str() }
    }

    /// Repeats the string n times.
    pub fn repeat(self, n: usize) -> String {
        var result: String = String.with_capacity(self.len * n)
        for _ in 0..n {
            result.push_str(self.as_str())
        }
        return result
    }
}

/// Iterator over the characters of a string.
pub struct Chars {
    data: str,
    pos: usize
}

impl Chars: Iterator {
    type Item = char

    fn next(self) -> Option[char] {
        if self.pos >= self.data.len() {
            return None
        } else {
            let ch: char = self.data.char_at(self.pos)
            self.pos = self.pos + ch.len_utf8()
            return Some(ch)
        }
    }
}

/// Iterator over the bytes of a string.
pub struct Bytes {
    data: [u8],
    pos: usize
}

impl Bytes: Iterator {
    type Item = u8

    fn next(self) -> Option[u8] {
        if self.pos >= self.data.len() {
            return None
        } else {
            let byte: u8 = self.data[self.pos]
            self.pos = self.pos + 1
            return Some(byte)
        }
    }
}

/// Iterator over the lines of a string.
pub struct Lines {
    remaining: str
}

impl Lines: Iterator {
    type Item = str

    fn next(self) -> Option[str] {
        if self.remaining.is_empty() {
            return None
        } else {
            match self.remaining.find('\n') {
                Some(idx) => {
                    let line: str = self.remaining[0..idx]
                    self.remaining = self.remaining[(idx + 1)..]
                    if line.ends_with('\r') {
                        return Some(line[0..(line.len() - 1)])
                    } else {
                        return Some(line)
                    }
                }
                None => {
                    let line: str = self.remaining
                    self.remaining = ""
                    return Some(line)
                }
            }
        }
    }
}

impl String: Clone {
    fn clone(self) -> String {
        return String.from(self.as_str())
    }
}

impl String: Eq {
    fn eq(self, other: String) -> bool {
        return self.as_str() == other.as_str()
    }
}

impl String: Ord {
    fn cmp(self, other: String) -> Ordering {
        return self.as_str().cmp(other.as_str())
    }
}

impl String: Display {
    fn display(self) -> String {
        return self.clone()
    }
}

impl String: Debug {
    fn debug(self) -> String {
        return "\"" + self.as_str() + "\""
    }
}

impl String: Default {
    fn default() -> String {
        return String.new()
    }
}

impl String: Hash {
    fn hash(self, hasher: Hasher) {
        for byte in self.bytes() {
            hasher.write_u8(byte)
        }
    }
}

// String concatenation operator
impl String: Add[String] {
    type Output = String

    fn add(self, other: String) -> String {
        return self.concat(other)
    }
}

impl String: Add[str] {
    type Output = String

    fn add(self, other: str) -> String {
        var result: String = self.clone()
        result.push_str(other)
        return result
    }
}
