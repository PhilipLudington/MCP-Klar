// Klar Standard Library - Reader
//
// The Reader trait and related types for reading bytes.

/// A trait for objects that can read bytes.
pub trait Reader {
    /// Pull some bytes from this source into the specified buffer.
    /// Returns how many bytes were read.
    fn read(self, buf: [u8]) -> IoResult[usize]

    /// Read exactly `buf.len()` bytes into the buffer.
    fn read_exact(self, buf: [u8]) -> IoResult[()] {
        var total: usize = 0
        while total < buf.len() {
            match self.read(buf[total..]) {
                Ok(0) => { return Err(Error.new(ErrorKind.Other, "unexpected end of file")) }
                Ok(n) => { total = total + n }
                Err(e) => { return Err(e) }
            }
        }
        return Ok(())
    }

    /// Read all bytes until EOF into the buffer.
    fn read_to_end(self, buf: List[u8]) -> IoResult[usize] {
        var total: usize = 0
        var chunk: [u8; 1024] = [0; 1024]

        loop {
            match self.read(chunk) {
                Ok(0) => { break }
                Ok(n) => {
                    for i in 0..n {
                        buf.push(chunk[i])
                    }
                    total = total + n
                }
                Err(e) => { return Err(e) }
            }
        }

        return Ok(total)
    }

    /// Read all bytes until EOF into a string.
    fn read_to_string(self, buf: String) -> IoResult[usize] {
        var bytes: List[u8] = List.new()
        let n = self.read_to_end(bytes)?

        match String.from_utf8(bytes) {
            Ok(s) => {
                buf.push_str(s.as_str())
                return Ok(n)
            }
            Err(_) => { return Err(Error.new(ErrorKind.InvalidData, "invalid UTF-8")) }
        }
    }

    /// Create a "by reference" adapter for this instance of Reader.
    fn by_ref(self) -> Self {
        return self
    }

    /// Transform this Reader into a BufReader.
    fn buffered(self) -> BufReader[Self] {
        return BufReader.new(self)
    }

    /// Create an iterator that reads bytes from this reader.
    fn bytes(self) -> Bytes[Self] {
        return Bytes { reader: self }
    }

    /// Create a reader that reads at most `limit` bytes.
    fn take(self, limit: usize) -> Take[Self] {
        return Take { reader: self, limit: limit }
    }

    /// Chain this reader with another.
    fn chain[R: Reader](self, next: R) -> Chain[Self, R] {
        return Chain { first: self, second: next, done_first: false }
    }
}

/// A buffered reader.
pub struct BufReader[R] {
    inner: R,
    buf: [u8; 8192],
    pos: usize,
    cap: usize
}

impl[R: Reader] BufReader[R] {
    /// Creates a new BufReader with a default buffer capacity.
    pub fn new(inner: R) -> BufReader[R] {
        return BufReader {
            inner: inner,
            buf: [0; 8192],
            pos: 0,
            cap: 0
        }
    }

    /// Creates a new BufReader with a specified capacity.
    pub fn with_capacity(capacity: usize, inner: R) -> BufReader[R] {
        return BufReader {
            inner: inner,
            buf: [0; capacity],
            pos: 0,
            cap: 0
        }
    }

    /// Gets a reference to the underlying reader.
    pub fn get_ref(self) -> R {
        return self.inner
    }

    /// Gets a mutable reference to the underlying reader.
    pub fn get_mut(self) -> R {
        return self.inner
    }

    /// Returns the number of bytes in the buffer.
    pub fn buffer(self) -> [u8] {
        return self.buf[self.pos..self.cap]
    }

    /// Consumes this BufReader, returning the underlying reader.
    pub fn into_inner(self) -> R {
        return self.inner
    }

    fn fill_buf(self) -> IoResult[[u8]] {
        if self.pos >= self.cap {
            self.cap = self.inner.read(self.buf)?
            self.pos = 0
        }
        return Ok(self.buf[self.pos..self.cap])
    }

    fn consume(self, amt: usize) {
        self.pos = self.pos.min(self.pos + amt)
    }
}

impl[R: Reader] BufReader[R]: Reader {
    fn read(self, buf: [u8]) -> IoResult[usize] {
        // If we have buffered data, use it first
        if self.pos < self.cap {
            let available = self.buf[self.pos..self.cap]
            let n = buf.len().min(available.len())
            for i in 0..n {
                buf[i] = available[i]
            }
            self.pos = self.pos + n
            return Ok(n)
        }

        // If the request is large, read directly
        if buf.len() >= self.buf.len() {
            return self.inner.read(buf)
        }

        // Fill the buffer and read from it
        self.fill_buf()?
        let available = self.buf[self.pos..self.cap]
        let n = buf.len().min(available.len())
        for i in 0..n {
            buf[i] = available[i]
        }
        self.pos = self.pos + n
        return Ok(n)
    }
}

impl[R: Reader] BufReader[R] {
    /// Read a line into the given string.
    pub fn read_line(self, buf: String) -> IoResult[usize] {
        var total: usize = 0

        loop {
            let available = self.fill_buf()?
            if available.is_empty() {
                break
            }

            // Look for newline
            match available.iter().position(fn(b: u8) -> bool { return b == '\n' as u8 }) {
                Some(i) => {
                    // Found newline
                    let line = available[0..i + 1]
                    buf.push_str(String.from_utf8_lossy(line).as_str())
                    total = total + line.len()
                    self.consume(i + 1)
                    break
                }
                None => {
                    // No newline, consume all available
                    buf.push_str(String.from_utf8_lossy(available).as_str())
                    total = total + available.len()
                    let len = available.len()
                    self.consume(len)
                }
            }
        }

        return Ok(total)
    }

    /// Returns an iterator over the lines of this reader.
    pub fn lines(self) -> Lines[R] {
        return Lines { reader: self }
    }

    /// Split this reader on a byte delimiter.
    pub fn split(self, byte: u8) -> Split[R] {
        return Split { reader: self, delim: byte }
    }
}

/// Iterator over bytes from a reader.
pub struct Bytes[R] {
    reader: R
}

impl[R: Reader] Bytes[R]: Iterator {
    type Item = IoResult[u8]

    fn next(self) -> Option[IoResult[u8]] {
        var buf: [u8; 1] = [0]
        match self.reader.read(buf) {
            Ok(0) => { return None }
            Ok(_) => { return Some(Ok(buf[0])) }
            Err(e) => { return Some(Err(e)) }
        }
    }
}

/// A reader that limits how many bytes can be read.
pub struct Take[R] {
    reader: R,
    limit: usize
}

impl[R: Reader] Take[R]: Reader {
    fn read(self, buf: [u8]) -> IoResult[usize] {
        if self.limit == 0 {
            return Ok(0)
        }

        let max = buf.len().min(self.limit)
        let n = self.reader.read(buf[0..max])?
        self.limit = self.limit - n
        return Ok(n)
    }
}

impl[R] Take[R] {
    /// Returns the number of bytes that can still be read.
    pub fn limit(self) -> usize {
        return self.limit
    }

    /// Sets the limit.
    pub fn set_limit(self, limit: usize) {
        self.limit = limit
    }

    /// Consumes this Take, returning the underlying reader.
    pub fn into_inner(self) -> R {
        return self.reader
    }
}

/// Chain two readers together.
pub struct Chain[R1, R2] {
    first: R1,
    second: R2,
    done_first: bool
}

impl[R1: Reader, R2: Reader] Chain[R1, R2]: Reader {
    fn read(self, buf: [u8]) -> IoResult[usize] {
        if not self.done_first {
            match self.first.read(buf)? {
                0 => { self.done_first = true }
                n => { return Ok(n) }
            }
        }
        return self.second.read(buf)
    }
}

impl[R1, R2] Chain[R1, R2] {
    /// Consumes this Chain, returning the underlying readers.
    pub fn into_inner(self) -> (R1, R2) {
        return (self.first, self.second)
    }

    /// Gets references to the underlying readers.
    pub fn get_ref(self) -> (R1, R2) {
        return (self.first, self.second)
    }
}

/// Iterator over lines from a buffered reader.
pub struct Lines[R] {
    reader: BufReader[R]
}

impl[R: Reader] Lines[R]: Iterator {
    type Item = IoResult[String]

    fn next(self) -> Option[IoResult[String]] {
        var line = String.new()
        match self.reader.read_line(line) {
            Ok(0) => { return None }
            Ok(_) => {
                // Remove trailing newline
                if line.ends_with("\n") {
                    line.pop()
                    if line.ends_with("\r") {
                        line.pop()
                    }
                }
                return Some(Ok(line))
            }
            Err(e) => { return Some(Err(e)) }
        }
    }
}

/// Iterator that splits on a delimiter.
pub struct Split[R] {
    reader: BufReader[R],
    delim: u8
}

impl[R: Reader] Split[R]: Iterator {
    type Item = IoResult[List[u8]]

    fn next(self) -> Option[IoResult[List[u8]]] {
        var buf: List[u8] = List.new()

        loop {
            let available = match self.reader.fill_buf() {
                Ok(b) => { b }
                Err(e) => { return Some(Err(e)) }
            }

            if available.is_empty() {
                if buf.is_empty() {
                    return None
                } else {
                    return Some(Ok(buf))
                }
            }

            match available.iter().position(fn(b: u8) -> bool { return b == self.delim }) {
                Some(i) => {
                    buf.extend(available[0..i])
                    self.reader.consume(i + 1)
                    return Some(Ok(buf))
                }
                None => {
                    buf.extend(available)
                    let len = available.len()
                    self.reader.consume(len)
                }
            }
        }
    }
}
