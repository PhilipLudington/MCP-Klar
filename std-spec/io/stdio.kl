// Klar Standard Library - Standard I/O
//
// Handles for standard input, output, and error streams.

/// A handle to the standard input stream.
pub struct Stdin {
    // Implementation-defined
}

/// A handle to the standard output stream.
pub struct Stdout {
    // Implementation-defined
}

/// A handle to the standard error stream.
pub struct Stderr {
    // Implementation-defined
}

/// Returns a handle to the standard input.
pub fn stdin() -> Stdin {
    return Stdin {}
}

/// Returns a handle to the standard output.
pub fn stdout() -> Stdout {
    return Stdout {}
}

/// Returns a handle to the standard error.
pub fn stderr() -> Stderr {
    return Stderr {}
}

impl Stdin {
    /// Reads a line from standard input into the given string.
    pub fn read_line(self, buf: String) -> IoResult[usize] {
        // Implementation provided by runtime
        var reader = self.lock()
        return reader.read_line(buf)
    }

    /// Locks this handle and returns a readable guard.
    pub fn lock(self) -> StdinLock {
        return StdinLock { inner: self }
    }

    /// Reads exactly `buf.len()` bytes or fails.
    pub fn read_exact(self, buf: [u8]) -> IoResult[()] {
        return self.lock().read_exact(buf)
    }
}

impl Stdin: Reader {
    fn read(self, buf: [u8]) -> IoResult[usize] {
        return self.lock().read(buf)
    }
}

/// A locked reference to Stdin.
pub struct StdinLock {
    inner: Stdin
}

impl StdinLock: Reader {
    fn read(self, buf: [u8]) -> IoResult[usize] {
        // Implementation provided by runtime
        return __builtin_stdin_read(buf)
    }
}

impl StdinLock {
    /// Read a line of input.
    pub fn read_line(self, buf: String) -> IoResult[usize] {
        // Implementation provided by runtime
        var bytes: List[u8] = List.new()
        var total: usize = 0

        loop {
            var byte: [u8; 1] = [0]
            match self.read(byte) {
                Ok(0) => { break }
                Ok(1) => {
                    total = total + 1
                    if byte[0] == '\n' as u8 {
                        bytes.push(byte[0])
                        break
                    }
                    bytes.push(byte[0])
                }
                Err(e) => { return Err(e) }
                _ => { break }
            }
        }

        match String.from_utf8(bytes) {
            Ok(s) => {
                buf.push_str(s.as_str())
                return Ok(total)
            }
            Err(_) => { return Err(Error.new(ErrorKind.InvalidData, "invalid UTF-8")) }
        }
    }
}

impl Stdout {
    /// Locks this handle and returns a writable guard.
    pub fn lock(self) -> StdoutLock {
        return StdoutLock { inner: self }
    }

    /// Write a string to stdout.
    pub fn write_str(self, s: str) -> IoResult[()] {
        return self.lock().write_all(s.as_bytes())
    }

    /// Write a line to stdout.
    pub fn write_line(self, s: str) -> IoResult[()] {
        var lock = self.lock()
        lock.write_all(s.as_bytes())?
        lock.write_all("\n".as_bytes())?
        return lock.flush()
    }
}

impl Stdout: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        return self.lock().write(buf)
    }

    fn flush(self) -> IoResult[()] {
        return self.lock().flush()
    }
}

/// A locked reference to Stdout.
pub struct StdoutLock {
    inner: Stdout
}

impl StdoutLock: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        // Implementation provided by runtime
        return __builtin_stdout_write(buf)
    }

    fn flush(self) -> IoResult[()] {
        // Implementation provided by runtime
        return __builtin_stdout_flush()
    }
}

impl Stderr {
    /// Locks this handle and returns a writable guard.
    pub fn lock(self) -> StderrLock {
        return StderrLock { inner: self }
    }

    /// Write a string to stderr.
    pub fn write_str(self, s: str) -> IoResult[()] {
        return self.lock().write_all(s.as_bytes())
    }

    /// Write a line to stderr.
    pub fn write_line(self, s: str) -> IoResult[()] {
        var lock = self.lock()
        lock.write_all(s.as_bytes())?
        lock.write_all("\n".as_bytes())?
        return lock.flush()
    }
}

impl Stderr: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        return self.lock().write(buf)
    }

    fn flush(self) -> IoResult[()] {
        return self.lock().flush()
    }
}

/// A locked reference to Stderr.
pub struct StderrLock {
    inner: Stderr
}

impl StderrLock: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        // Implementation provided by runtime
        return __builtin_stderr_write(buf)
    }

    fn flush(self) -> IoResult[()] {
        // Implementation provided by runtime
        return __builtin_stderr_flush()
    }
}

// Convenience functions

/// Print a string to standard output.
pub fn print(s: str) {
    let _ = stdout().write_str(s)
}

/// Print a string to standard output with a newline.
pub fn println(s: str) {
    let _ = stdout().write_line(s)
}

/// Print a string to standard error.
pub fn eprint(s: str) {
    let _ = stderr().write_str(s)
}

/// Print a string to standard error with a newline.
pub fn eprintln(s: str) {
    let _ = stderr().write_line(s)
}

/// Read a line from standard input.
pub fn input() -> IoResult[String] {
    var line = String.new()
    stdin().read_line(line)?
    // Remove trailing newline
    if line.ends_with("\n") {
        line.pop()
        if line.ends_with("\r") {
            line.pop()
        }
    }
    return Ok(line)
}

/// Read a line from standard input with a prompt.
pub fn input_with_prompt(prompt: str) -> IoResult[String] {
    print(prompt)
    stdout().flush()?
    return input()
}
