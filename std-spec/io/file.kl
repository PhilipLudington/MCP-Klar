// Klar Standard Library - File
//
// File handling and filesystem operations.

/// An open file handle.
pub struct File {
    // Implementation-defined handle
    handle: usize,
    path: String
}

impl File {
    /// Opens a file in read-only mode.
    pub fn open(path: str) -> IoResult[File] {
        return OpenOptions.new().read(true).open(path)
    }

    /// Opens a file in write-only mode.
    /// Creates the file if it doesn't exist, truncates it if it does.
    pub fn create(path: str) -> IoResult[File] {
        return OpenOptions.new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(path)
    }

    /// Opens a file in append mode.
    /// Creates the file if it doesn't exist.
    pub fn append(path: str) -> IoResult[File] {
        return OpenOptions.new()
            .write(true)
            .append(true)
            .create(true)
            .open(path)
    }

    /// Returns the path of this file.
    pub fn path(self) -> str {
        return self.path.as_str()
    }

    /// Synchronizes all modified content to the filesystem.
    pub fn sync_all(self) -> IoResult[()] {
        // Implementation provided by runtime
        return __builtin_file_sync_all(self.handle)
    }

    /// Synchronizes content but not metadata.
    pub fn sync_data(self) -> IoResult[()] {
        // Implementation provided by runtime
        return __builtin_file_sync_data(self.handle)
    }

    /// Sets the length of the file.
    pub fn set_len(self, size: usize) -> IoResult[()] {
        // Implementation provided by runtime
        return __builtin_file_set_len(self.handle, size)
    }

    /// Returns metadata about the file.
    pub fn metadata(self) -> IoResult[Metadata] {
        // Implementation provided by runtime
        return __builtin_file_metadata(self.handle)
    }

    /// Creates a new independently owned handle to the underlying file.
    pub fn try_clone(self) -> IoResult[File] {
        // Implementation provided by runtime
        let new_handle = __builtin_file_clone(self.handle)?
        return Ok(File { handle: new_handle, path: self.path.clone() })
    }
}

impl File: Reader {
    fn read(self, buf: [u8]) -> IoResult[usize] {
        // Implementation provided by runtime
        return __builtin_file_read(self.handle, buf)
    }
}

impl File: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        // Implementation provided by runtime
        return __builtin_file_write(self.handle, buf)
    }

    fn flush(self) -> IoResult[()] {
        // Implementation provided by runtime
        return __builtin_file_flush(self.handle)
    }
}

impl File: Drop {
    fn drop(self) {
        // Implementation provided by runtime
        let _ = __builtin_file_close(self.handle)
    }
}

/// Options for opening files.
pub struct OpenOptions {
    read: bool,
    write: bool,
    append: bool,
    truncate: bool,
    create: bool,
    create_new: bool
}

impl OpenOptions {
    /// Creates a new OpenOptions with all options set to false.
    pub fn new() -> OpenOptions {
        return OpenOptions {
            read: false,
            write: false,
            append: false,
            truncate: false,
            create: false,
            create_new: false
        }
    }

    /// Sets the option for read access.
    pub fn read(self, read: bool) -> OpenOptions {
        self.read = read
        return self
    }

    /// Sets the option for write access.
    pub fn write(self, write: bool) -> OpenOptions {
        self.write = write
        return self
    }

    /// Sets the option for append mode.
    pub fn append(self, append: bool) -> OpenOptions {
        self.append = append
        return self
    }

    /// Sets the option for truncating the file.
    pub fn truncate(self, truncate: bool) -> OpenOptions {
        self.truncate = truncate
        return self
    }

    /// Sets the option for creating a new file.
    pub fn create(self, create: bool) -> OpenOptions {
        self.create = create
        return self
    }

    /// Sets the option for creating a new file exclusively.
    pub fn create_new(self, create_new: bool) -> OpenOptions {
        self.create_new = create_new
        return self
    }

    /// Opens a file at the given path with the options specified.
    pub fn open(self, path: str) -> IoResult[File] {
        // Implementation provided by runtime
        let handle = __builtin_file_open(
            path,
            self.read,
            self.write,
            self.append,
            self.truncate,
            self.create,
            self.create_new
        )?
        return Ok(File { handle: handle, path: String.from(path) })
    }
}

/// Metadata about a file.
pub struct Metadata {
    len: usize,
    is_dir: bool,
    is_file: bool,
    is_symlink: bool,
    created: Option[SystemTime],
    modified: Option[SystemTime],
    accessed: Option[SystemTime],
    permissions: Permissions
}

impl Metadata {
    /// Returns the size of the file in bytes.
    pub fn len(self) -> usize {
        return self.len
    }

    /// Returns true if this is a directory.
    pub fn is_dir(self) -> bool {
        return self.is_dir
    }

    /// Returns true if this is a regular file.
    pub fn is_file(self) -> bool {
        return self.is_file
    }

    /// Returns true if this is a symbolic link.
    pub fn is_symlink(self) -> bool {
        return self.is_symlink
    }

    /// Returns the creation time.
    pub fn created(self) -> Option[SystemTime] {
        return self.created
    }

    /// Returns the last modification time.
    pub fn modified(self) -> Option[SystemTime] {
        return self.modified
    }

    /// Returns the last access time.
    pub fn accessed(self) -> Option[SystemTime] {
        return self.accessed
    }

    /// Returns the permissions.
    pub fn permissions(self) -> Permissions {
        return self.permissions
    }
}

/// File permissions.
pub struct Permissions {
    readonly: bool,
    mode: u32
}

impl Permissions {
    /// Returns true if the file is read-only.
    pub fn readonly(self) -> bool {
        return self.readonly
    }

    /// Sets whether the file is read-only.
    pub fn set_readonly(self, readonly: bool) {
        self.readonly = readonly
    }

    /// Returns the raw permission mode (Unix).
    pub fn mode(self) -> u32 {
        return self.mode
    }

    /// Sets the raw permission mode (Unix).
    pub fn set_mode(self, mode: u32) {
        self.mode = mode
    }
}

/// System time representation.
pub struct SystemTime {
    secs: u64,
    nanos: u32
}

// Convenience functions for file operations

/// Read the entire contents of a file into a string.
pub fn read_to_string(path: str) -> IoResult[String] {
    var file = File.open(path)?
    var contents = String.new()
    file.read_to_string(contents)?
    return Ok(contents)
}

/// Read the entire contents of a file into a byte list.
pub fn read(path: str) -> IoResult[List[u8]] {
    var file = File.open(path)?
    var contents: List[u8] = List.new()
    file.read_to_end(contents)?
    return Ok(contents)
}

/// Write bytes to a file.
pub fn write(path: str, contents: [u8]) -> IoResult[()] {
    var file = File.create(path)?
    return file.write_all(contents)
}

/// Write a string to a file.
pub fn write_str(path: str, contents: str) -> IoResult[()] {
    return write(path, contents.as_bytes())
}

/// Remove a file.
pub fn remove_file(path: str) -> IoResult[()] {
    // Implementation provided by runtime
    return __builtin_remove_file(path)
}

/// Rename a file.
pub fn rename(from: str, to: str) -> IoResult[()] {
    // Implementation provided by runtime
    return __builtin_rename(from, to)
}

/// Copy a file.
pub fn copy(from: str, to: str) -> IoResult[usize] {
    var src = File.open(from)?
    var dst = File.create(to)?
    return io.copy(src, dst)
}

/// Create a new directory.
pub fn create_dir(path: str) -> IoResult[()] {
    // Implementation provided by runtime
    return __builtin_create_dir(path)
}

/// Create a directory and all parent directories.
pub fn create_dir_all(path: str) -> IoResult[()] {
    // Implementation provided by runtime
    return __builtin_create_dir_all(path)
}

/// Remove a directory.
pub fn remove_dir(path: str) -> IoResult[()] {
    // Implementation provided by runtime
    return __builtin_remove_dir(path)
}

/// Remove a directory and all its contents.
pub fn remove_dir_all(path: str) -> IoResult[()] {
    // Implementation provided by runtime
    return __builtin_remove_dir_all(path)
}

/// Read the entries of a directory.
pub fn read_dir(path: str) -> IoResult[ReadDir] {
    // Implementation provided by runtime
    let entries = __builtin_read_dir(path)?
    return Ok(ReadDir { entries: entries, index: 0 })
}

/// Iterator over directory entries.
pub struct ReadDir {
    entries: List[DirEntry],
    index: usize
}

impl ReadDir: Iterator {
    type Item = IoResult[DirEntry]

    fn next(self) -> Option[IoResult[DirEntry]] {
        if self.index < self.entries.len() {
            let entry = self.entries[self.index].clone()
            self.index = self.index + 1
            return Some(Ok(entry))
        } else {
            return None
        }
    }
}

/// An entry in a directory.
pub struct DirEntry {
    path: String,
    file_name: String
}

impl DirEntry {
    /// Returns the full path of this entry.
    pub fn path(self) -> str {
        return self.path.as_str()
    }

    /// Returns the file name of this entry.
    pub fn file_name(self) -> str {
        return self.file_name.as_str()
    }

    /// Returns the metadata for this entry.
    pub fn metadata(self) -> IoResult[Metadata] {
        // Implementation provided by runtime
        return __builtin_metadata(self.path.as_str())
    }

    /// Returns the file type for this entry.
    pub fn file_type(self) -> IoResult[FileType] {
        let meta = self.metadata()?
        return Ok(FileType {
            is_dir: meta.is_dir(),
            is_file: meta.is_file(),
            is_symlink: meta.is_symlink()
        })
    }
}

impl DirEntry: Clone {
    fn clone(self) -> DirEntry {
        return DirEntry {
            path: self.path.clone(),
            file_name: self.file_name.clone()
        }
    }
}

/// A file type.
pub struct FileType {
    is_dir: bool,
    is_file: bool,
    is_symlink: bool
}

impl FileType {
    pub fn is_dir(self) -> bool {
        return self.is_dir
    }

    pub fn is_file(self) -> bool {
        return self.is_file
    }

    pub fn is_symlink(self) -> bool {
        return self.is_symlink
    }
}

/// Check if a path exists.
pub fn exists(path: str) -> bool {
    return __builtin_path_exists(path)
}

/// Get metadata for a path.
pub fn metadata(path: str) -> IoResult[Metadata] {
    return __builtin_metadata(path)
}

/// Get the canonical, absolute path.
pub fn canonicalize(path: str) -> IoResult[String] {
    return __builtin_canonicalize(path)
}

/// Get the current working directory.
pub fn current_dir() -> IoResult[String] {
    return __builtin_current_dir()
}

/// Set the current working directory.
pub fn set_current_dir(path: str) -> IoResult[()] {
    return __builtin_set_current_dir(path)
}
