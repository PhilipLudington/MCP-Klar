// Klar Standard Library - Writer
//
// The Writer trait and related types for writing bytes.

/// A trait for objects that can write bytes.
pub trait Writer {
    /// Write a buffer into this writer.
    /// Returns how many bytes were written.
    fn write(self, buf: [u8]) -> IoResult[usize]

    /// Flush this output stream, ensuring all buffered data is written.
    fn flush(self) -> IoResult[()]

    /// Write all bytes from the buffer.
    fn write_all(self, buf: [u8]) -> IoResult[()] {
        var written: usize = 0
        while written < buf.len() {
            match self.write(buf[written..]) {
                Ok(0) => { return Err(Error.new(ErrorKind.Other, "write returned zero")) }
                Ok(n) => { written = written + n }
                Err(e) => { return Err(e) }
            }
        }
        return Ok(())
    }

    /// Write a formatted string to this writer.
    fn write_fmt(self, args: Arguments) -> IoResult[()] {
        let s = format(args)
        return self.write_all(s.as_bytes())
    }

    /// Create a "by reference" adapter for this instance of Writer.
    fn by_ref(self) -> Self {
        return self
    }

    /// Transform this Writer into a BufWriter.
    fn buffered(self) -> BufWriter[Self] {
        return BufWriter.new(self)
    }
}

/// A buffered writer.
pub struct BufWriter[W] {
    inner: W,
    buf: List[u8],
    capacity: usize
}

impl[W: Writer] BufWriter[W] {
    /// Creates a new BufWriter with a default buffer capacity.
    pub fn new(inner: W) -> BufWriter[W] {
        return BufWriter.with_capacity(8192, inner)
    }

    /// Creates a new BufWriter with a specified capacity.
    pub fn with_capacity(capacity: usize, inner: W) -> BufWriter[W] {
        return BufWriter {
            inner: inner,
            buf: List.with_capacity(capacity),
            capacity: capacity
        }
    }

    /// Gets a reference to the underlying writer.
    pub fn get_ref(self) -> W {
        return self.inner
    }

    /// Gets a mutable reference to the underlying writer.
    pub fn get_mut(self) -> W {
        return self.inner
    }

    /// Returns the number of bytes in the buffer.
    pub fn buffer(self) -> [u8] {
        return self.buf.as_slice()
    }

    /// Returns the capacity of the internal buffer.
    pub fn capacity(self) -> usize {
        return self.capacity
    }

    /// Consumes this BufWriter, returning the underlying writer.
    /// Any buffered data is written first.
    pub fn into_inner(self) -> Result[W, IntoInnerError[BufWriter[W]]] {
        match self.flush_buf() {
            Ok(()) => { return Ok(self.inner) }
            Err(e) => { return Err(IntoInnerError { error: e, buffer: self }) }
        }
    }

    fn flush_buf(self) -> IoResult[()] {
        var written: usize = 0
        let len = self.buf.len()

        while written < len {
            match self.inner.write(self.buf.as_slice()[written..]) {
                Ok(0) => { return Err(Error.new(ErrorKind.Other, "write returned zero")) }
                Ok(n) => { written = written + n }
                Err(e) => {
                    // Remove the written bytes from the buffer
                    for _ in 0..written {
                        self.buf.remove(0)
                    }
                    return Err(e)
                }
            }
        }

        self.buf.clear()
        return Ok(())
    }
}

impl[W: Writer] BufWriter[W]: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        // If the write is larger than the buffer, flush and write directly
        if buf.len() >= self.capacity {
            self.flush_buf()?
            return self.inner.write(buf)
        }

        // If the buffer would overflow, flush first
        if self.buf.len() + buf.len() > self.capacity {
            self.flush_buf()?
        }

        // Add to buffer
        for b in buf {
            self.buf.push(b)
        }
        return Ok(buf.len())
    }

    fn flush(self) -> IoResult[()] {
        self.flush_buf()?
        return self.inner.flush()
    }
}

impl[W: Writer] BufWriter[W]: Drop {
    fn drop(self) {
        // Try to flush on drop, ignore errors
        let _ = self.flush_buf()
    }
}

/// Error returned when consuming a BufWriter fails.
pub struct IntoInnerError[W] {
    error: IoError,
    buffer: W
}

impl[W] IntoInnerError[W] {
    /// Returns the error that caused the failure.
    pub fn error(self) -> IoError {
        return self.error
    }

    /// Returns the buffered writer that failed to flush.
    pub fn into_inner(self) -> W {
        return self.buffer
    }
}

/// A writer that keeps track of how many bytes have been written.
pub struct CountingWriter[W] {
    inner: W,
    count: usize
}

impl[W: Writer] CountingWriter[W] {
    /// Creates a new CountingWriter.
    pub fn new(inner: W) -> CountingWriter[W] {
        return CountingWriter { inner: inner, count: 0 }
    }

    /// Returns the number of bytes written.
    pub fn count(self) -> usize {
        return self.count
    }

    /// Gets a reference to the underlying writer.
    pub fn get_ref(self) -> W {
        return self.inner
    }

    /// Gets a mutable reference to the underlying writer.
    pub fn get_mut(self) -> W {
        return self.inner
    }

    /// Consumes this CountingWriter, returning the underlying writer.
    pub fn into_inner(self) -> W {
        return self.inner
    }
}

impl[W: Writer] CountingWriter[W]: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        let n = self.inner.write(buf)?
        self.count = self.count + n
        return Ok(n)
    }

    fn flush(self) -> IoResult[()] {
        return self.inner.flush()
    }
}

/// A writer that writes to a list of bytes.
pub struct VecWriter {
    data: List[u8]
}

impl VecWriter {
    /// Creates a new VecWriter.
    pub fn new() -> VecWriter {
        return VecWriter { data: List.new() }
    }

    /// Creates a new VecWriter with a specified capacity.
    pub fn with_capacity(capacity: usize) -> VecWriter {
        return VecWriter { data: List.with_capacity(capacity) }
    }

    /// Returns the written data.
    pub fn into_inner(self) -> List[u8] {
        return self.data
    }

    /// Returns a reference to the written data.
    pub fn get_ref(self) -> List[u8] {
        return self.data
    }
}

impl VecWriter: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        for b in buf {
            self.data.push(b)
        }
        return Ok(buf.len())
    }

    fn flush(self) -> IoResult[()] {
        return Ok(())
    }
}

/// A writer that broadcasts to multiple writers.
pub struct MultiWriter[W] {
    writers: List[W]
}

impl[W: Writer] MultiWriter[W] {
    /// Creates a new MultiWriter.
    pub fn new() -> MultiWriter[W] {
        return MultiWriter { writers: List.new() }
    }

    /// Adds a writer.
    pub fn add(self, writer: W) {
        self.writers.push(writer)
    }
}

impl[W: Writer] MultiWriter[W]: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        for writer in self.writers.iter() {
            writer.write_all(buf)?
        }
        return Ok(buf.len())
    }

    fn flush(self) -> IoResult[()] {
        for writer in self.writers.iter() {
            writer.flush()?
        }
        return Ok(())
    }
}

/// A writer that writes to two writers simultaneously.
pub struct TeeWriter[W1, W2] {
    first: W1,
    second: W2
}

impl[W1: Writer, W2: Writer] TeeWriter[W1, W2] {
    /// Creates a new TeeWriter.
    pub fn new(first: W1, second: W2) -> TeeWriter[W1, W2] {
        return TeeWriter { first: first, second: second }
    }

    /// Consumes this TeeWriter, returning the underlying writers.
    pub fn into_inner(self) -> (W1, W2) {
        return (self.first, self.second)
    }
}

impl[W1: Writer, W2: Writer] TeeWriter[W1, W2]: Writer {
    fn write(self, buf: [u8]) -> IoResult[usize] {
        self.first.write_all(buf)?
        self.second.write_all(buf)?
        return Ok(buf.len())
    }

    fn flush(self) -> IoResult[()] {
        self.first.flush()?
        return self.second.flush()
    }
}
