// Klar Standard Library - Result
//
// The Result type represents either success (Ok) or failure (Err).
// It is used for error handling in a type-safe way.

/// Result is a type that represents either success (Ok) or failure (Err).
/// It is the idiomatic way to handle errors in Klar.
pub enum Result[T, E] {
    /// Contains the success value.
    Ok(T),
    /// Contains the error value.
    Err(E)
}

impl[T, E] Result[T, E] {
    /// Returns true if the result is Ok.
    pub fn is_ok(self) -> bool {
        match self {
            Ok(_) => { return true }
            Err(_) => { return false }
        }
    }

    /// Returns true if the result is Err.
    pub fn is_err(self) -> bool {
        match self {
            Ok(_) => { return false }
            Err(_) => { return true }
        }
    }

    /// Converts from Result[T, E] to Option[T], discarding the error if any.
    pub fn ok(self) -> Option[T] {
        match self {
            Ok(value) => { return Some(value) }
            Err(_) => { return None }
        }
    }

    /// Converts from Result[T, E] to Option[E], discarding the success value if any.
    pub fn err(self) -> Option[E] {
        match self {
            Ok(_) => { return None }
            Err(error) => { return Some(error) }
        }
    }

    /// Returns the contained Ok value, panicking if the result is Err.
    /// Use with caution - prefer `unwrap_or` or pattern matching.
    pub fn unwrap(self) -> T {
        match self {
            Ok(value) => { return value }
            Err(_) => { panic("called Result.unwrap() on an Err value") }
        }
    }

    /// Returns the contained Err value, panicking if the result is Ok.
    pub fn unwrap_err(self) -> E {
        match self {
            Ok(_) => { panic("called Result.unwrap_err() on an Ok value") }
            Err(error) => { return error }
        }
    }

    /// Returns the contained Ok value or a default.
    pub fn unwrap_or(self, default: T) -> T {
        match self {
            Ok(value) => { return value }
            Err(_) => { return default }
        }
    }

    /// Returns the contained Ok value or computes it from a closure.
    pub fn unwrap_or_else(self, f: fn(E) -> T) -> T {
        match self {
            Ok(value) => { return value }
            Err(error) => { return f(error) }
        }
    }

    /// Maps a Result[T, E] to Result[U, E] by applying a function to the Ok value.
    pub fn map[U](self, f: fn(T) -> U) -> Result[U, E] {
        match self {
            Ok(value) => { return Ok(f(value)) }
            Err(error) => { return Err(error) }
        }
    }

    /// Maps a Result[T, E] to Result[T, F] by applying a function to the Err value.
    pub fn map_err[F](self, f: fn(E) -> F) -> Result[T, F] {
        match self {
            Ok(value) => { return Ok(value) }
            Err(error) => { return Err(f(error)) }
        }
    }

    /// Calls f if the result is Ok, otherwise returns the Err value.
    pub fn and_then[U](self, f: fn(T) -> Result[U, E]) -> Result[U, E] {
        match self {
            Ok(value) => { return f(value) }
            Err(error) => { return Err(error) }
        }
    }

    /// Returns the result if it is Ok, otherwise returns res.
    pub fn or(self, res: Result[T, E]) -> Result[T, E] {
        match self {
            Ok(_) => { return self }
            Err(_) => { return res }
        }
    }

    /// Returns the result if it is Ok, otherwise calls f and returns the result.
    pub fn or_else[F](self, f: fn(E) -> Result[T, F]) -> Result[T, F] {
        match self {
            Ok(value) => { return Ok(value) }
            Err(error) => { return f(error) }
        }
    }

    /// Returns true if the result is Ok and the value inside matches a predicate.
    pub fn is_ok_and(self, f: fn(T) -> bool) -> bool {
        match self {
            Ok(value) => { return f(value) }
            Err(_) => { return false }
        }
    }

    /// Returns true if the result is Err and the value inside matches a predicate.
    pub fn is_err_and(self, f: fn(E) -> bool) -> bool {
        match self {
            Ok(_) => { return false }
            Err(error) => { return f(error) }
        }
    }
}

impl[T: Clone, E: Clone] Result[T, E]: Clone {
    fn clone(self) -> Result[T, E] {
        match self {
            Ok(value) => { return Ok(value.clone()) }
            Err(error) => { return Err(error.clone()) }
        }
    }
}

impl[T: Eq, E: Eq] Result[T, E]: Eq {
    fn eq(self, other: Result[T, E]) -> bool {
        match (self, other) {
            (Ok(a), Ok(b)) => { return a == b }
            (Err(a), Err(b)) => { return a == b }
            _ => { return false }
        }
    }
}

impl[T: Display, E: Display] Result[T, E]: Display {
    fn display(self) -> String {
        match self {
            Ok(value) => { return "Ok(" + value.display() + ")" }
            Err(error) => { return "Err(" + error.display() + ")" }
        }
    }
}

impl[T: Debug, E: Debug] Result[T, E]: Debug {
    fn debug(self) -> String {
        match self {
            Ok(value) => { return "Ok(" + value.debug() + ")" }
            Err(error) => { return "Err(" + error.debug() + ")" }
        }
    }
}

impl[T: Default, E] Result[T, E]: Default {
    fn default() -> Result[T, E] {
        return Ok(T.default())
    }
}

// Common error type for standard library operations
pub struct Error {
    message: String,
    kind: ErrorKind
}

pub enum ErrorKind {
    NotFound,
    PermissionDenied,
    AlreadyExists,
    InvalidInput,
    InvalidData,
    TimedOut,
    Interrupted,
    OutOfMemory,
    Other
}

impl Error {
    pub fn new(kind: ErrorKind, message: String) -> Error {
        return Error { kind: kind, message: message }
    }

    pub fn kind(self) -> ErrorKind {
        return self.kind
    }

    pub fn message(self) -> String {
        return self.message
    }
}

impl Error: Display {
    fn display(self) -> String {
        return self.message
    }
}

impl Error: Debug {
    fn debug(self) -> String {
        return "Error { kind: " + self.kind.debug() + ", message: " + self.message + " }"
    }
}

impl ErrorKind: Display {
    fn display(self) -> String {
        match self {
            NotFound => { return "not found" }
            PermissionDenied => { return "permission denied" }
            AlreadyExists => { return "already exists" }
            InvalidInput => { return "invalid input" }
            InvalidData => { return "invalid data" }
            TimedOut => { return "timed out" }
            Interrupted => { return "interrupted" }
            OutOfMemory => { return "out of memory" }
            Other => { return "other error" }
        }
    }
}

impl ErrorKind: Debug {
    fn debug(self) -> String {
        match self {
            NotFound => { return "NotFound" }
            PermissionDenied => { return "PermissionDenied" }
            AlreadyExists => { return "AlreadyExists" }
            InvalidInput => { return "InvalidInput" }
            InvalidData => { return "InvalidData" }
            TimedOut => { return "TimedOut" }
            Interrupted => { return "Interrupted" }
            OutOfMemory => { return "OutOfMemory" }
            Other => { return "Other" }
        }
    }
}
