// Klar Standard Library - List
//
// A contiguous growable array type.

/// A contiguous growable array type, written as List[T].
/// Lists can grow and shrink dynamically.
pub struct List[T] {
    data: [T],
    len: usize,
    capacity: usize
}

impl[T] List[T] {
    /// Creates a new, empty List.
    pub fn new() -> List[T] {
        return List { data: [], len: 0, capacity: 0 }
    }

    /// Creates a new List with the specified capacity.
    pub fn with_capacity(capacity: usize) -> List[T] {
        return List { data: [], len: 0, capacity: capacity }
    }

    /// Creates a List from an array.
    pub fn from_array(arr: [T]) -> List[T] {
        return List { data: arr, len: arr.len(), capacity: arr.len() }
    }

    /// Returns the number of elements in the list.
    pub fn len(self) -> usize {
        return self.len
    }

    /// Returns true if the list contains no elements.
    pub fn is_empty(self) -> bool {
        return self.len == 0
    }

    /// Returns the current capacity of the list.
    pub fn capacity(self) -> usize {
        return self.capacity
    }

    /// Appends an element to the back of the list.
    pub fn push(self, value: T) {
        if self.len >= self.capacity {
            self.grow()
        }
        self.data.push(value)
        self.len = self.len + 1
    }

    /// Removes the last element from the list and returns it.
    pub fn pop(self) -> Option[T] {
        if self.is_empty() {
            return None
        } else {
            self.len = self.len - 1
            return Some(self.data.pop())
        }
    }

    /// Returns a reference to the element at the given index.
    pub fn get(self, index: usize) -> Option[T] {
        if index < self.len {
            return Some(self.data[index])
        } else {
            return None
        }
    }

    /// Returns a reference to the first element, or None if empty.
    pub fn first(self) -> Option[T] {
        return self.get(0)
    }

    /// Returns a reference to the last element, or None if empty.
    pub fn last(self) -> Option[T] {
        if self.is_empty() {
            return None
        } else {
            return self.get(self.len - 1)
        }
    }

    /// Inserts an element at the given index, shifting all elements after it.
    pub fn insert(self, index: usize, value: T) {
        if index > self.len {
            panic("index out of bounds")
        }
        if self.len >= self.capacity {
            self.grow()
        }
        // Shift elements to the right
        for i in (index..self.len).rev() {
            self.data[i + 1] = self.data[i]
        }
        self.data[index] = value
        self.len = self.len + 1
    }

    /// Removes and returns the element at the given index, shifting all elements after it.
    pub fn remove(self, index: usize) -> T {
        if index >= self.len {
            panic("index out of bounds")
        }
        let value: T = self.data[index]
        // Shift elements to the left
        for i in index..(self.len - 1) {
            self.data[i] = self.data[i + 1]
        }
        self.len = self.len - 1
        return value
    }

    /// Removes and returns the element at the given index by swapping it with the last element.
    /// This is O(1) but does not preserve order.
    pub fn swap_remove(self, index: usize) -> T {
        if index >= self.len {
            panic("index out of bounds")
        }
        let value: T = self.data[index]
        self.data[index] = self.data[self.len - 1]
        self.len = self.len - 1
        return value
    }

    /// Clears the list, removing all elements.
    pub fn clear(self) {
        self.len = 0
    }

    /// Truncates the list, keeping the first `len` elements and dropping the rest.
    pub fn truncate(self, new_len: usize) {
        if new_len < self.len {
            self.len = new_len
        }
    }

    /// Reserves capacity for at least `additional` more elements.
    pub fn reserve(self, additional: usize) {
        let required: usize = self.len + additional
        if required > self.capacity {
            self.grow_to(required)
        }
    }

    /// Shrinks the capacity to match the length.
    pub fn shrink_to_fit(self) {
        self.capacity = self.len
    }

    /// Returns true if the list contains the given element.
    pub fn contains(self, value: T) -> bool
    where T: Eq
    {
        for item in self.iter() {
            if item == value {
                return true
            }
        }
        return false
    }

    /// Returns the index of the first occurrence of the given element.
    pub fn index_of(self, value: T) -> Option[usize]
    where T: Eq
    {
        for (i, item) in self.iter().enumerate() {
            if item == value {
                return Some(i)
            }
        }
        return None
    }

    /// Returns an iterator over the elements.
    pub fn iter(self) -> ListIter[T] {
        return ListIter { list: self, index: 0 }
    }

    /// Returns a slice containing all the elements.
    pub fn as_slice(self) -> [T] {
        return self.data[0..self.len]
    }

    /// Appends all elements from another list.
    pub fn extend(self, other: List[T])
    where T: Clone
    {
        self.reserve(other.len())
        for item in other.iter() {
            self.push(item.clone())
        }
    }

    /// Reverses the order of elements in place.
    pub fn reverse(self) {
        var i: usize = 0
        var j: usize = self.len - 1
        while i < j {
            let temp: T = self.data[i]
            self.data[i] = self.data[j]
            self.data[j] = temp
            i = i + 1
            j = j - 1
        }
    }

    /// Sorts the list in place.
    pub fn sort(self)
    where T: Ord
    {
        // Simple insertion sort for now
        for i in 1..self.len {
            let key: T = self.data[i]
            var j: isize = (i - 1) as isize
            while j >= 0 and self.data[j as usize] > key {
                self.data[(j + 1) as usize] = self.data[j as usize]
                j = j - 1
            }
            self.data[(j + 1) as usize] = key
        }
    }

    /// Maps each element to a new value.
    pub fn map[U](self, f: fn(T) -> U) -> List[U] {
        var result: List[U] = List.with_capacity(self.len)
        for item in self.iter() {
            result.push(f(item))
        }
        return result
    }

    /// Filters elements based on a predicate.
    pub fn filter(self, predicate: fn(T) -> bool) -> List[T]
    where T: Clone
    {
        var result: List[T] = List.new()
        for item in self.iter() {
            if predicate(item) {
                result.push(item.clone())
            }
        }
        return result
    }

    /// Reduces the list to a single value.
    pub fn fold[U](self, init: U, f: fn(U, T) -> U) -> U {
        var acc: U = init
        for item in self.iter() {
            acc = f(acc, item)
        }
        return acc
    }

    /// Returns true if any element matches the predicate.
    pub fn any(self, predicate: fn(T) -> bool) -> bool {
        for item in self.iter() {
            if predicate(item) {
                return true
            }
        }
        return false
    }

    /// Returns true if all elements match the predicate.
    pub fn all(self, predicate: fn(T) -> bool) -> bool {
        for item in self.iter() {
            if not predicate(item) {
                return false
            }
        }
        return true
    }

    /// Returns the first element matching the predicate.
    pub fn find(self, predicate: fn(T) -> bool) -> Option[T] {
        for item in self.iter() {
            if predicate(item) {
                return Some(item)
            }
        }
        return None
    }

    // Private methods

    fn grow(self) {
        let new_capacity: usize = if self.capacity == 0 {
            4
        } else {
            self.capacity * 2
        }
        self.grow_to(new_capacity)
    }

    fn grow_to(self, new_capacity: usize) {
        self.capacity = new_capacity
    }
}

/// Iterator over a List.
pub struct ListIter[T] {
    list: List[T],
    index: usize
}

impl[T] ListIter[T]: Iterator {
    type Item = T

    fn next(self) -> Option[T] {
        if self.index < self.list.len {
            let item: T = self.list.data[self.index]
            self.index = self.index + 1
            return Some(item)
        } else {
            return None
        }
    }
}

impl[T: Clone] List[T]: Clone {
    fn clone(self) -> List[T] {
        var result: List[T] = List.with_capacity(self.len)
        for item in self.iter() {
            result.push(item.clone())
        }
        return result
    }
}

impl[T: Eq] List[T]: Eq {
    fn eq(self, other: List[T]) -> bool {
        if self.len != other.len {
            return false
        }
        for i in 0..self.len {
            if self.data[i] != other.data[i] {
                return false
            }
        }
        return true
    }
}

impl[T: Display] List[T]: Display {
    fn display(self) -> String {
        var result: String = "["
        var first: bool = true
        for item in self.iter() {
            if not first {
                result = result + ", "
            }
            result = result + item.display()
            first = false
        }
        return result + "]"
    }
}

impl[T: Debug] List[T]: Debug {
    fn debug(self) -> String {
        var result: String = "List(["
        var first: bool = true
        for item in self.iter() {
            if not first {
                result = result + ", "
            }
            result = result + item.debug()
            first = false
        }
        return result + "])"
    }
}

impl[T] List[T]: Default {
    fn default() -> List[T] {
        return List.new()
    }
}

// Index operator
impl[T] List[T]: Index[usize] {
    type Output = T

    fn index(self, idx: usize) -> T {
        return self.get(idx).unwrap()
    }
}
