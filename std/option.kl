// Klar Standard Library - Option
//
// The Option type represents an optional value: every Option is either Some
// and contains a value, or None and does not.

/// Option is a type that represents either a value (Some) or nothing (None).
/// It is used to handle nullable values in a type-safe way.
pub enum Option<T> {
    /// Contains a value of type T.
    Some(T),
    /// Contains no value.
    None
}

impl<T> Option<T> {
    /// Returns true if the option is Some.
    pub fn is_some(self) -> bool {
        match self {
            Some(_) => true,
            None => false
        }
    }

    /// Returns true if the option is None.
    pub fn is_none(self) -> bool {
        match self {
            Some(_) => false,
            None => true
        }
    }

    /// Returns the contained value, panicking if None.
    /// Use with caution - prefer `unwrap_or` or pattern matching.
    pub fn unwrap(self) -> T {
        match self {
            Some(value) => value,
            None => panic("called Option::unwrap() on a None value")
        }
    }

    /// Returns the contained value or a default.
    pub fn unwrap_or(self, default: T) -> T {
        match self {
            Some(value) => value,
            None => default
        }
    }

    /// Returns the contained value or computes it from a closure.
    pub fn unwrap_or_else(self, f: fn() -> T) -> T {
        match self {
            Some(value) => value,
            None => f()
        }
    }

    /// Maps an Option<T> to Option<U> by applying a function to a contained value.
    pub fn map<U>(self, f: fn(T) -> U) -> Option<U> {
        match self {
            Some(value) => Some(f(value)),
            None => None
        }
    }

    /// Returns None if the option is None, otherwise calls f with the wrapped value
    /// and returns the result.
    pub fn and_then<U>(self, f: fn(T) -> Option<U>) -> Option<U> {
        match self {
            Some(value) => f(value),
            None => None
        }
    }

    /// Returns the option if it contains a value, otherwise returns optb.
    pub fn or(self, optb: Option<T>) -> Option<T> {
        match self {
            Some(_) => self,
            None => optb
        }
    }

    /// Returns the option if it contains a value, otherwise calls f and returns the result.
    pub fn or_else(self, f: fn() -> Option<T>) -> Option<T> {
        match self {
            Some(_) => self,
            None => f()
        }
    }

    /// Transforms the Option<T> into a Result<T, E>, mapping Some(v) to Ok(v)
    /// and None to Err(err).
    pub fn ok_or<E>(self, err: E) -> Result<T, E> {
        match self {
            Some(value) => Ok(value),
            None => Err(err)
        }
    }

    /// Takes the value out of the option, leaving a None in its place.
    pub fn take(mut self) -> Option<T> {
        let result = self
        self = None
        result
    }

    /// Replaces the actual value in the option by the value given in parameter,
    /// returning the old value if present.
    pub fn replace(mut self, value: T) -> Option<T> {
        let old = self
        self = Some(value)
        old
    }

    /// Returns true if the option is Some and the contained value equals the given value.
    pub fn contains<U>(self, x: &U) -> bool
    where T: Eq<U>
    {
        match self {
            Some(ref value) => value == x,
            None => false
        }
    }

    /// Converts from &Option<T> to Option<&T>.
    pub fn as_ref(&self) -> Option<&T> {
        match self {
            Some(ref value) => Some(value),
            None => None
        }
    }

    /// Converts from &mut Option<T> to Option<&mut T>.
    pub fn as_mut(&mut self) -> Option<&mut T> {
        match self {
            Some(ref mut value) => Some(value),
            None => None
        }
    }

    /// Returns an iterator over the possibly contained value.
    pub fn iter(&self) -> OptionIter<T> {
        OptionIter { inner: self.as_ref() }
    }
}

/// Iterator over an Option value.
pub struct OptionIter<T> {
    inner: Option<&T>
}

impl<T> Iterator for OptionIter<T> {
    type Item = &T

    fn next(mut self) -> Option<&T> {
        self.inner.take()
    }
}

impl<T: Clone> Option<T> {
    /// Returns a copy of the contained value if Some, or None.
    pub fn cloned(&self) -> Option<T> {
        match self {
            Some(ref value) => Some(value.clone()),
            None => None
        }
    }
}

impl<T: Default> Option<T> {
    /// Returns the contained value or a default.
    pub fn unwrap_or_default(self) -> T {
        match self {
            Some(value) => value,
            None => T::default()
        }
    }
}

impl<T: Display> Display for Option<T> {
    fn display(self) -> String {
        match self {
            Some(value) => "Some(" + value.display() + ")",
            None => "None"
        }
    }
}

impl<T: Debug> Debug for Option<T> {
    fn debug(self) -> String {
        match self {
            Some(value) => "Some(" + value.debug() + ")",
            None => "None"
        }
    }
}

impl<T: Eq> Eq for Option<T> {
    fn eq(self, other: Option<T>) -> bool {
        match (self, other) {
            (Some(a), Some(b)) => a == b,
            (None, None) => true,
            _ => false
        }
    }
}

impl<T: Clone> Clone for Option<T> {
    fn clone(self) -> Option<T> {
        match self {
            Some(value) => Some(value.clone()),
            None => None
        }
    }
}

impl<T> Default for Option<T> {
    fn default() -> Option<T> {
        None
    }
}
