// Klar Standard Library - Set
//
// A hash set implementation for unique value storage.

/// A hash set implemented with a Map<T, ()>.
pub struct Set<T> {
    map: Map<T, ()>
}

impl<T: Hash + Eq> Set<T> {
    /// Creates a new, empty Set.
    pub fn new() -> Set<T> {
        Set { map: Map::new() }
    }

    /// Creates a new Set with the specified capacity.
    pub fn with_capacity(capacity: usize) -> Set<T> {
        Set { map: Map::with_capacity(capacity) }
    }

    /// Returns the number of elements in the set.
    pub fn len(&self) -> usize {
        self.map.len()
    }

    /// Returns true if the set contains no elements.
    pub fn is_empty(&self) -> bool {
        self.map.is_empty()
    }

    /// Returns the current capacity of the set.
    pub fn capacity(&self) -> usize {
        self.map.capacity()
    }

    /// Adds a value to the set.
    /// Returns true if the value was newly inserted.
    pub fn insert(&mut self, value: T) -> bool {
        self.map.insert(value, ()).is_none()
    }

    /// Removes a value from the set.
    /// Returns true if the value was present.
    pub fn remove(&mut self, value: &T) -> bool {
        self.map.remove(value).is_some()
    }

    /// Returns true if the set contains the given value.
    pub fn contains(&self, value: &T) -> bool {
        self.map.contains_key(value)
    }

    /// Clears the set, removing all values.
    pub fn clear(&mut self) {
        self.map.clear()
    }

    /// Returns an iterator over the values.
    pub fn iter(&self) -> SetIter<T> {
        SetIter { iter: self.map.keys() }
    }

    /// Returns true if self has no elements in common with other.
    pub fn is_disjoint(&self, other: &Set<T>) -> bool {
        for value in self.iter() {
            if other.contains(value) {
                return false
            }
        }
        true
    }

    /// Returns true if self is a subset of other.
    pub fn is_subset(&self, other: &Set<T>) -> bool {
        for value in self.iter() {
            if not other.contains(value) {
                return false
            }
        }
        true
    }

    /// Returns true if self is a superset of other.
    pub fn is_superset(&self, other: &Set<T>) -> bool {
        other.is_subset(self)
    }

    /// Returns the intersection of self and other as a new Set.
    pub fn intersection(&self, other: &Set<T>) -> Set<T>
    where T: Clone
    {
        let mut result: Set<T> = Set::new()
        for value in self.iter() {
            if other.contains(value) {
                result.insert(value.clone())
            }
        }
        result
    }

    /// Returns the union of self and other as a new Set.
    pub fn union(&self, other: &Set<T>) -> Set<T>
    where T: Clone
    {
        let mut result: Set<T> = Set::new()
        for value in self.iter() {
            result.insert(value.clone())
        }
        for value in other.iter() {
            result.insert(value.clone())
        }
        result
    }

    /// Returns the difference of self and other as a new Set.
    /// The difference contains elements that are in self but not in other.
    pub fn difference(&self, other: &Set<T>) -> Set<T>
    where T: Clone
    {
        let mut result: Set<T> = Set::new()
        for value in self.iter() {
            if not other.contains(value) {
                result.insert(value.clone())
            }
        }
        result
    }

    /// Returns the symmetric difference of self and other as a new Set.
    /// The symmetric difference contains elements that are in either set but not both.
    pub fn symmetric_difference(&self, other: &Set<T>) -> Set<T>
    where T: Clone
    {
        let mut result: Set<T> = Set::new()
        for value in self.iter() {
            if not other.contains(value) {
                result.insert(value.clone())
            }
        }
        for value in other.iter() {
            if not self.contains(value) {
                result.insert(value.clone())
            }
        }
        result
    }

    /// Retains only the elements specified by the predicate.
    pub fn retain(&mut self, predicate: fn(&T) -> bool) {
        self.map.retain(|k, _| predicate(k))
    }

    /// Takes the value out of the set if present.
    pub fn take(&mut self, value: &T) -> Option<T>
    where T: Clone
    {
        if self.remove(value) {
            Some(value.clone())
        } else {
            None
        }
    }

    /// Adds a value to the set, replacing the existing value if present.
    /// Returns the replaced value.
    pub fn replace(&mut self, value: T) -> Option<T>
    where T: Clone
    {
        if self.contains(&value) {
            let old = value.clone()
            self.insert(value)
            Some(old)
        } else {
            self.insert(value)
            None
        }
    }
}

/// Iterator over a Set.
pub struct SetIter<T> {
    iter: Keys<T, ()>
}

impl<T> Iterator for SetIter<T> {
    type Item = &T

    fn next(&mut self) -> Option<&T> {
        self.iter.next()
    }
}

impl<T: Clone + Hash + Eq> Clone for Set<T> {
    fn clone(&self) -> Set<T> {
        let mut result: Set<T> = Set::with_capacity(self.capacity())
        for value in self.iter() {
            result.insert(value.clone())
        }
        result
    }
}

impl<T: Eq + Hash> Eq for Set<T> {
    fn eq(&self, other: &Set<T>) -> bool {
        if self.len() != other.len() {
            return false
        }
        for value in self.iter() {
            if not other.contains(value) {
                return false
            }
        }
        true
    }
}

impl<T: Debug + Hash + Eq> Debug for Set<T> {
    fn debug(&self) -> String {
        let mut result = "Set({"
        let mut first = true
        for value in self.iter() {
            if not first {
                result = result + ", "
            }
            result = result + value.debug()
            first = false
        }
        result + "})"
    }
}

impl<T: Hash + Eq> Default for Set<T> {
    fn default() -> Set<T> {
        Set::new()
    }
}

// Set operations using operators

impl<T: Clone + Hash + Eq> BitOr for Set<T> {
    type Output = Set<T>

    /// Returns the union of two sets.
    fn bitor(self, other: Set<T>) -> Set<T> {
        self.union(&other)
    }
}

impl<T: Clone + Hash + Eq> BitAnd for Set<T> {
    type Output = Set<T>

    /// Returns the intersection of two sets.
    fn bitand(self, other: Set<T>) -> Set<T> {
        self.intersection(&other)
    }
}

impl<T: Clone + Hash + Eq> Sub for Set<T> {
    type Output = Set<T>

    /// Returns the difference of two sets.
    fn sub(self, other: Set<T>) -> Set<T> {
        self.difference(&other)
    }
}

impl<T: Clone + Hash + Eq> BitXor for Set<T> {
    type Output = Set<T>

    /// Returns the symmetric difference of two sets.
    fn bitxor(self, other: Set<T>) -> Set<T> {
        self.symmetric_difference(&other)
    }
}
