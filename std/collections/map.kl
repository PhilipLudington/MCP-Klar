// Klar Standard Library - Map
//
// A hash map implementation for key-value storage.

/// A hash map implemented with quadratic probing and SIMD lookup.
pub struct Map<K, V> {
    entries: [MapEntry<K, V>],
    len: usize,
    capacity: usize
}

/// An entry in the hash map.
struct MapEntry<K, V> {
    key: K,
    value: V,
    hash: u64,
    occupied: bool
}

impl<K: Hash + Eq, V> Map<K, V> {
    /// Creates a new, empty Map.
    pub fn new() -> Map<K, V> {
        Map { entries: [], len: 0, capacity: 0 }
    }

    /// Creates a new Map with the specified capacity.
    pub fn with_capacity(capacity: usize) -> Map<K, V> {
        Map { entries: [], len: 0, capacity: capacity }
    }

    /// Returns the number of elements in the map.
    pub fn len(&self) -> usize {
        self.len
    }

    /// Returns true if the map contains no elements.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    /// Returns the current capacity of the map.
    pub fn capacity(&self) -> usize {
        self.capacity
    }

    /// Inserts a key-value pair into the map.
    /// If the key already exists, the value is updated and the old value is returned.
    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
        if self.should_grow() {
            self.grow()
        }

        let hash = self.hash_key(&key)
        let index = self.find_slot(&key, hash)

        if self.entries[index].occupied {
            let old_value = self.entries[index].value
            self.entries[index].value = value
            Some(old_value)
        } else {
            self.entries[index] = MapEntry {
                key: key,
                value: value,
                hash: hash,
                occupied: true
            }
            self.len = self.len + 1
            None
        }
    }

    /// Returns a reference to the value corresponding to the key.
    pub fn get(&self, key: &K) -> Option<&V> {
        if self.is_empty() {
            return None
        }

        let hash = self.hash_key(key)
        let index = self.find_slot(key, hash)

        if self.entries[index].occupied {
            Some(&self.entries[index].value)
        } else {
            None
        }
    }

    /// Returns a mutable reference to the value corresponding to the key.
    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {
        if self.is_empty() {
            return None
        }

        let hash = self.hash_key(key)
        let index = self.find_slot(key, hash)

        if self.entries[index].occupied {
            Some(&mut self.entries[index].value)
        } else {
            None
        }
    }

    /// Returns true if the map contains the given key.
    pub fn contains_key(&self, key: &K) -> bool {
        self.get(key).is_some()
    }

    /// Removes a key from the map, returning the value if present.
    pub fn remove(&mut self, key: &K) -> Option<V> {
        if self.is_empty() {
            return None
        }

        let hash = self.hash_key(key)
        let index = self.find_slot(key, hash)

        if self.entries[index].occupied {
            self.entries[index].occupied = false
            self.len = self.len - 1
            Some(self.entries[index].value)
        } else {
            None
        }
    }

    /// Clears the map, removing all key-value pairs.
    pub fn clear(&mut self) {
        for entry in &mut self.entries {
            entry.occupied = false
        }
        self.len = 0
    }

    /// Gets the given key's corresponding entry for in-place manipulation.
    pub fn entry(&mut self, key: K) -> Entry<K, V> {
        let hash = self.hash_key(&key)
        let index = self.find_slot(&key, hash)

        if self.entries[index].occupied {
            Entry::Occupied(OccupiedEntry {
                map: self,
                index: index
            })
        } else {
            Entry::Vacant(VacantEntry {
                map: self,
                key: key,
                hash: hash,
                index: index
            })
        }
    }

    /// Returns an iterator over the keys.
    pub fn keys(&self) -> Keys<K, V> {
        Keys { iter: self.iter() }
    }

    /// Returns an iterator over the values.
    pub fn values(&self) -> Values<K, V> {
        Values { iter: self.iter() }
    }

    /// Returns a mutable iterator over the values.
    pub fn values_mut(&mut self) -> ValuesMut<K, V> {
        ValuesMut { iter: self.iter_mut() }
    }

    /// Returns an iterator over the key-value pairs.
    pub fn iter(&self) -> MapIter<K, V> {
        MapIter { entries: &self.entries, index: 0 }
    }

    /// Returns a mutable iterator over the key-value pairs.
    pub fn iter_mut(&mut self) -> MapIterMut<K, V> {
        MapIterMut { entries: &mut self.entries, index: 0 }
    }

    /// Retains only the elements specified by the predicate.
    pub fn retain(&mut self, predicate: fn(&K, &V) -> bool) {
        for entry in &mut self.entries {
            if entry.occupied and not predicate(&entry.key, &entry.value) {
                entry.occupied = false
                self.len = self.len - 1
            }
        }
    }

    // Private methods

    fn hash_key(&self, key: &K) -> u64 {
        let mut hasher = DefaultHasher::new()
        key.hash(&mut hasher)
        hasher.finish()
    }

    fn find_slot(&self, key: &K, hash: u64) -> usize {
        if self.capacity == 0 {
            return 0
        }

        let mut index = (hash as usize) % self.capacity
        let mut probe: usize = 0

        while self.entries[index].occupied and self.entries[index].key != *key {
            probe = probe + 1
            index = (index + probe * probe) % self.capacity
        }

        index
    }

    fn should_grow(&self) -> bool {
        self.capacity == 0 or self.len * 4 >= self.capacity * 3
    }

    fn grow(&mut self) {
        let new_capacity = if self.capacity == 0 {
            16
        } else {
            self.capacity * 2
        }

        let old_entries = self.entries
        self.entries = []
        self.capacity = new_capacity
        self.len = 0

        for entry in old_entries {
            if entry.occupied {
                self.insert(entry.key, entry.value)
            }
        }
    }
}

/// A view into a single entry in a map.
pub enum Entry<K, V> {
    Occupied(OccupiedEntry<K, V>),
    Vacant(VacantEntry<K, V>)
}

impl<K: Hash + Eq, V> Entry<K, V> {
    /// Ensures a value is in the entry by inserting the default if empty.
    pub fn or_insert(self, default: V) -> &mut V {
        match self {
            Occupied(entry) => entry.into_mut(),
            Vacant(entry) => entry.insert(default)
        }
    }

    /// Ensures a value is in the entry by inserting the result of the function if empty.
    pub fn or_insert_with(self, default: fn() -> V) -> &mut V {
        match self {
            Occupied(entry) => entry.into_mut(),
            Vacant(entry) => entry.insert(default())
        }
    }

    /// Returns a reference to this entry's key.
    pub fn key(&self) -> &K {
        match self {
            Occupied(entry) => entry.key(),
            Vacant(entry) => &entry.key
        }
    }
}

/// A view into an occupied entry in a Map.
pub struct OccupiedEntry<K, V> {
    map: &mut Map<K, V>,
    index: usize
}

impl<K: Hash + Eq, V> OccupiedEntry<K, V> {
    /// Gets a reference to the key in the entry.
    pub fn key(&self) -> &K {
        &self.map.entries[self.index].key
    }

    /// Gets a reference to the value in the entry.
    pub fn get(&self) -> &V {
        &self.map.entries[self.index].value
    }

    /// Gets a mutable reference to the value in the entry.
    pub fn get_mut(&mut self) -> &mut V {
        &mut self.map.entries[self.index].value
    }

    /// Converts the entry into a mutable reference to its value.
    pub fn into_mut(self) -> &mut V {
        &mut self.map.entries[self.index].value
    }

    /// Sets the value of the entry and returns the old value.
    pub fn insert(&mut self, value: V) -> V {
        let old = self.map.entries[self.index].value
        self.map.entries[self.index].value = value
        old
    }

    /// Removes the entry and returns the value.
    pub fn remove(self) -> V {
        self.map.entries[self.index].occupied = false
        self.map.len = self.map.len - 1
        self.map.entries[self.index].value
    }
}

/// A view into a vacant entry in a Map.
pub struct VacantEntry<K, V> {
    map: &mut Map<K, V>,
    key: K,
    hash: u64,
    index: usize
}

impl<K: Hash + Eq, V> VacantEntry<K, V> {
    /// Gets a reference to the key.
    pub fn key(&self) -> &K {
        &self.key
    }

    /// Sets the value of the entry and returns a mutable reference to it.
    pub fn insert(self, value: V) -> &mut V {
        if self.map.should_grow() {
            self.map.grow()
        }

        let index = self.map.find_slot(&self.key, self.hash)
        self.map.entries[index] = MapEntry {
            key: self.key,
            value: value,
            hash: self.hash,
            occupied: true
        }
        self.map.len = self.map.len + 1
        &mut self.map.entries[index].value
    }
}

/// Iterator over the entries of a Map.
pub struct MapIter<K, V> {
    entries: &[MapEntry<K, V>],
    index: usize
}

impl<K, V> Iterator for MapIter<K, V> {
    type Item = (&K, &V)

    fn next(&mut self) -> Option<(&K, &V)> {
        while self.index < self.entries.len() {
            let entry = &self.entries[self.index]
            self.index = self.index + 1
            if entry.occupied {
                return Some((&entry.key, &entry.value))
            }
        }
        None
    }
}

/// Mutable iterator over the entries of a Map.
pub struct MapIterMut<K, V> {
    entries: &mut [MapEntry<K, V>],
    index: usize
}

impl<K, V> Iterator for MapIterMut<K, V> {
    type Item = (&K, &mut V)

    fn next(&mut self) -> Option<(&K, &mut V)> {
        while self.index < self.entries.len() {
            let entry = &mut self.entries[self.index]
            self.index = self.index + 1
            if entry.occupied {
                return Some((&entry.key, &mut entry.value))
            }
        }
        None
    }
}

/// Iterator over the keys of a Map.
pub struct Keys<K, V> {
    iter: MapIter<K, V>
}

impl<K, V> Iterator for Keys<K, V> {
    type Item = &K

    fn next(&mut self) -> Option<&K> {
        self.iter.next().map(|(k, _)| k)
    }
}

/// Iterator over the values of a Map.
pub struct Values<K, V> {
    iter: MapIter<K, V>
}

impl<K, V> Iterator for Values<K, V> {
    type Item = &V

    fn next(&mut self) -> Option<&V> {
        self.iter.next().map(|(_, v)| v)
    }
}

/// Mutable iterator over the values of a Map.
pub struct ValuesMut<K, V> {
    iter: MapIterMut<K, V>
}

impl<K, V> Iterator for ValuesMut<K, V> {
    type Item = &mut V

    fn next(&mut self) -> Option<&mut V> {
        self.iter.next().map(|(_, v)| v)
    }
}

impl<K: Clone + Hash + Eq, V: Clone> Clone for Map<K, V> {
    fn clone(&self) -> Map<K, V> {
        let mut result: Map<K, V> = Map::with_capacity(self.capacity)
        for (k, v) in self.iter() {
            result.insert(k.clone(), v.clone())
        }
        result
    }
}

impl<K: Eq + Hash, V: Eq> Eq for Map<K, V> {
    fn eq(&self, other: &Map<K, V>) -> bool {
        if self.len != other.len {
            return false
        }
        for (k, v) in self.iter() {
            match other.get(k) {
                Some(other_v) => {
                    if v != other_v {
                        return false
                    }
                },
                None => return false
            }
        }
        true
    }
}

impl<K: Debug + Hash + Eq, V: Debug> Debug for Map<K, V> {
    fn debug(&self) -> String {
        let mut result = "Map({"
        let mut first = true
        for (k, v) in self.iter() {
            if not first {
                result = result + ", "
            }
            result = result + k.debug() + ": " + v.debug()
            first = false
        }
        result + "})"
    }
}

impl<K: Hash + Eq, V> Default for Map<K, V> {
    fn default() -> Map<K, V> {
        Map::new()
    }
}

// Index operator
impl<K: Hash + Eq, V> Index<K> for Map<K, V> {
    type Output = V

    fn index(&self, key: K) -> &V {
        self.get(&key).unwrap()
    }
}
