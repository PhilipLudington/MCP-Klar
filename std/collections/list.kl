// Klar Standard Library - List
//
// A contiguous growable array type.

/// A contiguous growable array type, written as List<T>.
/// Lists can grow and shrink dynamically.
pub struct List<T> {
    data: [T],
    len: usize,
    capacity: usize
}

impl<T> List<T> {
    /// Creates a new, empty List.
    pub fn new() -> List<T> {
        List { data: [], len: 0, capacity: 0 }
    }

    /// Creates a new List with the specified capacity.
    pub fn with_capacity(capacity: usize) -> List<T> {
        List { data: [], len: 0, capacity: capacity }
    }

    /// Creates a List from an array.
    pub fn from_array(arr: [T]) -> List<T> {
        List { data: arr, len: arr.len(), capacity: arr.len() }
    }

    /// Returns the number of elements in the list.
    pub fn len(&self) -> usize {
        self.len
    }

    /// Returns true if the list contains no elements.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    /// Returns the current capacity of the list.
    pub fn capacity(&self) -> usize {
        self.capacity
    }

    /// Appends an element to the back of the list.
    pub fn push(&mut self, value: T) {
        if self.len >= self.capacity {
            self.grow()
        }
        self.data.push(value)
        self.len = self.len + 1
    }

    /// Removes the last element from the list and returns it.
    pub fn pop(&mut self) -> Option<T> {
        if self.is_empty() {
            None
        } else {
            self.len = self.len - 1
            Some(self.data.pop())
        }
    }

    /// Returns a reference to the element at the given index.
    pub fn get(&self, index: usize) -> Option<&T> {
        if index < self.len {
            Some(&self.data[index])
        } else {
            None
        }
    }

    /// Returns a mutable reference to the element at the given index.
    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {
        if index < self.len {
            Some(&mut self.data[index])
        } else {
            None
        }
    }

    /// Returns a reference to the first element, or None if empty.
    pub fn first(&self) -> Option<&T> {
        self.get(0)
    }

    /// Returns a reference to the last element, or None if empty.
    pub fn last(&self) -> Option<&T> {
        if self.is_empty() {
            None
        } else {
            self.get(self.len - 1)
        }
    }

    /// Inserts an element at the given index, shifting all elements after it.
    pub fn insert(&mut self, index: usize, value: T) {
        if index > self.len {
            panic("index out of bounds")
        }
        if self.len >= self.capacity {
            self.grow()
        }
        // Shift elements to the right
        for i in (index..self.len).rev() {
            self.data[i + 1] = self.data[i]
        }
        self.data[index] = value
        self.len = self.len + 1
    }

    /// Removes and returns the element at the given index, shifting all elements after it.
    pub fn remove(&mut self, index: usize) -> T {
        if index >= self.len {
            panic("index out of bounds")
        }
        let value = self.data[index]
        // Shift elements to the left
        for i in index..(self.len - 1) {
            self.data[i] = self.data[i + 1]
        }
        self.len = self.len - 1
        value
    }

    /// Removes and returns the element at the given index by swapping it with the last element.
    /// This is O(1) but does not preserve order.
    pub fn swap_remove(&mut self, index: usize) -> T {
        if index >= self.len {
            panic("index out of bounds")
        }
        let value = self.data[index]
        self.data[index] = self.data[self.len - 1]
        self.len = self.len - 1
        value
    }

    /// Clears the list, removing all elements.
    pub fn clear(&mut self) {
        self.len = 0
    }

    /// Truncates the list, keeping the first `len` elements and dropping the rest.
    pub fn truncate(&mut self, new_len: usize) {
        if new_len < self.len {
            self.len = new_len
        }
    }

    /// Reserves capacity for at least `additional` more elements.
    pub fn reserve(&mut self, additional: usize) {
        let required = self.len + additional
        if required > self.capacity {
            self.grow_to(required)
        }
    }

    /// Shrinks the capacity to match the length.
    pub fn shrink_to_fit(&mut self) {
        self.capacity = self.len
    }

    /// Returns true if the list contains the given element.
    pub fn contains(&self, value: &T) -> bool
    where T: Eq
    {
        for item in self.iter() {
            if item == value {
                return true
            }
        }
        false
    }

    /// Returns the index of the first occurrence of the given element.
    pub fn index_of(&self, value: &T) -> Option<usize>
    where T: Eq
    {
        for (i, item) in self.iter().enumerate() {
            if item == value {
                return Some(i)
            }
        }
        None
    }

    /// Returns an iterator over the elements.
    pub fn iter(&self) -> ListIter<T> {
        ListIter { list: self, index: 0 }
    }

    /// Returns an iterator that allows modifying each element.
    pub fn iter_mut(&mut self) -> ListIterMut<T> {
        ListIterMut { list: self, index: 0 }
    }

    /// Returns a slice containing all the elements.
    pub fn as_slice(&self) -> &[T] {
        &self.data[0..self.len]
    }

    /// Appends all elements from another list.
    pub fn extend(&mut self, other: &List<T>)
    where T: Clone
    {
        self.reserve(other.len())
        for item in other.iter() {
            self.push(item.clone())
        }
    }

    /// Reverses the order of elements in place.
    pub fn reverse(&mut self) {
        let mut i: usize = 0
        let mut j: usize = self.len - 1
        while i < j {
            let temp = self.data[i]
            self.data[i] = self.data[j]
            self.data[j] = temp
            i = i + 1
            j = j - 1
        }
    }

    /// Sorts the list in place.
    pub fn sort(&mut self)
    where T: Ord
    {
        // Simple insertion sort for now
        for i in 1..self.len {
            let key = self.data[i]
            let mut j: isize = (i - 1) as isize
            while j >= 0 and self.data[j as usize] > key {
                self.data[(j + 1) as usize] = self.data[j as usize]
                j = j - 1
            }
            self.data[(j + 1) as usize] = key
        }
    }

    /// Sorts the list in place using a comparison function.
    pub fn sort_by(&mut self, compare: fn(&T, &T) -> Ordering) {
        for i in 1..self.len {
            let key = self.data[i]
            let mut j: isize = (i - 1) as isize
            while j >= 0 and compare(&self.data[j as usize], &key) == Ordering::Greater {
                self.data[(j + 1) as usize] = self.data[j as usize]
                j = j - 1
            }
            self.data[(j + 1) as usize] = key
        }
    }

    /// Maps each element to a new value.
    pub fn map<U>(&self, f: fn(&T) -> U) -> List<U> {
        let mut result: List<U> = List::with_capacity(self.len)
        for item in self.iter() {
            result.push(f(item))
        }
        result
    }

    /// Filters elements based on a predicate.
    pub fn filter(&self, predicate: fn(&T) -> bool) -> List<T>
    where T: Clone
    {
        let mut result: List<T> = List::new()
        for item in self.iter() {
            if predicate(item) {
                result.push(item.clone())
            }
        }
        result
    }

    /// Reduces the list to a single value.
    pub fn fold<U>(&self, init: U, f: fn(U, &T) -> U) -> U {
        let mut acc = init
        for item in self.iter() {
            acc = f(acc, item)
        }
        acc
    }

    /// Returns true if any element matches the predicate.
    pub fn any(&self, predicate: fn(&T) -> bool) -> bool {
        for item in self.iter() {
            if predicate(item) {
                return true
            }
        }
        false
    }

    /// Returns true if all elements match the predicate.
    pub fn all(&self, predicate: fn(&T) -> bool) -> bool {
        for item in self.iter() {
            if not predicate(item) {
                return false
            }
        }
        true
    }

    /// Returns the first element matching the predicate.
    pub fn find(&self, predicate: fn(&T) -> bool) -> Option<&T> {
        for item in self.iter() {
            if predicate(item) {
                return Some(item)
            }
        }
        None
    }

    // Private methods

    fn grow(&mut self) {
        let new_capacity = if self.capacity == 0 {
            4
        } else {
            self.capacity * 2
        }
        self.grow_to(new_capacity)
    }

    fn grow_to(&mut self, new_capacity: usize) {
        // Implementation would reallocate the underlying array
        self.capacity = new_capacity
    }
}

/// Iterator over a List.
pub struct ListIter<T> {
    list: &List<T>,
    index: usize
}

impl<T> Iterator for ListIter<T> {
    type Item = &T

    fn next(&mut self) -> Option<&T> {
        if self.index < self.list.len {
            let item = &self.list.data[self.index]
            self.index = self.index + 1
            Some(item)
        } else {
            None
        }
    }
}

/// Mutable iterator over a List.
pub struct ListIterMut<T> {
    list: &mut List<T>,
    index: usize
}

impl<T> Iterator for ListIterMut<T> {
    type Item = &mut T

    fn next(&mut self) -> Option<&mut T> {
        if self.index < self.list.len {
            let item = &mut self.list.data[self.index]
            self.index = self.index + 1
            Some(item)
        } else {
            None
        }
    }
}

impl<T: Clone> Clone for List<T> {
    fn clone(&self) -> List<T> {
        let mut result: List<T> = List::with_capacity(self.len)
        for item in self.iter() {
            result.push(item.clone())
        }
        result
    }
}

impl<T: Eq> Eq for List<T> {
    fn eq(&self, other: &List<T>) -> bool {
        if self.len != other.len {
            return false
        }
        for i in 0..self.len {
            if self.data[i] != other.data[i] {
                return false
            }
        }
        true
    }
}

impl<T: Display> Display for List<T> {
    fn display(&self) -> String {
        let mut result = "["
        let mut first = true
        for item in self.iter() {
            if not first {
                result = result + ", "
            }
            result = result + item.display()
            first = false
        }
        result + "]"
    }
}

impl<T: Debug> Debug for List<T> {
    fn debug(&self) -> String {
        let mut result = "List(["
        let mut first = true
        for item in self.iter() {
            if not first {
                result = result + ", "
            }
            result = result + item.debug()
            first = false
        }
        result + "])"
    }
}

impl<T> Default for List<T> {
    fn default() -> List<T> {
        List::new()
    }
}

// Index operator
impl<T> Index<usize> for List<T> {
    type Output = T

    fn index(&self, idx: usize) -> &T {
        self.get(idx).unwrap()
    }
}

impl<T> IndexMut<usize> for List<T> {
    fn index_mut(&mut self, idx: usize) -> &mut T {
        self.get_mut(idx).unwrap()
    }
}
