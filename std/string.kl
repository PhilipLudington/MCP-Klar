// Klar Standard Library - String
//
// The String type represents a growable, UTF-8 encoded string.

/// A UTF-8 encoded, growable string.
pub struct String {
    data: [u8],
    len: usize
}

impl String {
    /// Creates a new empty String.
    pub fn new() -> String {
        String { data: [], len: 0 }
    }

    /// Creates a new String with the given capacity.
    pub fn with_capacity(capacity: usize) -> String {
        String { data: [], len: 0 }
    }

    /// Creates a String from a string literal.
    pub fn from(s: str) -> String {
        String { data: s.as_bytes(), len: s.len() }
    }

    /// Returns the length of the string in bytes.
    pub fn len(&self) -> usize {
        self.len
    }

    /// Returns true if the string is empty.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    /// Returns the string as a str slice.
    pub fn as_str(&self) -> str {
        // Implementation provided by runtime
        self.data.as_str()
    }

    /// Returns a byte slice of the string contents.
    pub fn as_bytes(&self) -> &[u8] {
        &self.data
    }

    /// Appends a string slice to this String.
    pub fn push_str(&mut self, s: str) {
        for byte in s.as_bytes() {
            self.data.push(byte)
        }
        self.len = self.len + s.len()
    }

    /// Appends a character to this String.
    pub fn push(&mut self, ch: char) {
        // UTF-8 encode the character and append bytes
        let bytes = ch.encode_utf8()
        for byte in bytes {
            self.data.push(byte)
        }
        self.len = self.len + bytes.len()
    }

    /// Removes the last character from the string and returns it.
    pub fn pop(&mut self) -> Option<char> {
        if self.is_empty() {
            None
        } else {
            // UTF-8 decode the last character
            let ch = self.chars().last()
            if ch.is_some() {
                let char_len = ch.unwrap().len_utf8()
                self.len = self.len - char_len
                self.data.truncate(self.len)
            }
            ch
        }
    }

    /// Clears the string, removing all contents.
    pub fn clear(&mut self) {
        self.data.clear()
        self.len = 0
    }

    /// Concatenates two strings.
    pub fn concat(&self, other: &String) -> String {
        let mut result = self.clone()
        result.push_str(other.as_str())
        result
    }

    /// Returns true if the string contains the given substring.
    pub fn contains(&self, pattern: str) -> bool {
        self.find(pattern).is_some()
    }

    /// Returns true if the string starts with the given prefix.
    pub fn starts_with(&self, prefix: str) -> bool {
        if prefix.len() > self.len {
            false
        } else {
            self.as_str()[0..prefix.len()] == prefix
        }
    }

    /// Returns true if the string ends with the given suffix.
    pub fn ends_with(&self, suffix: str) -> bool {
        if suffix.len() > self.len {
            false
        } else {
            self.as_str()[(self.len - suffix.len())..self.len] == suffix
        }
    }

    /// Returns the index of the first occurrence of the pattern, or None.
    pub fn find(&self, pattern: str) -> Option<usize> {
        if pattern.is_empty() {
            return Some(0)
        }
        if pattern.len() > self.len {
            return None
        }
        for i in 0..(self.len - pattern.len() + 1) {
            if self.as_str()[i..(i + pattern.len())] == pattern {
                return Some(i)
            }
        }
        None
    }

    /// Returns the index of the last occurrence of the pattern, or None.
    pub fn rfind(&self, pattern: str) -> Option<usize> {
        if pattern.is_empty() {
            return Some(self.len)
        }
        if pattern.len() > self.len {
            return None
        }
        for i in (0..(self.len - pattern.len() + 1)).rev() {
            if self.as_str()[i..(i + pattern.len())] == pattern {
                return Some(i)
            }
        }
        None
    }

    /// Replaces all occurrences of a pattern with another string.
    pub fn replace(&self, from: str, to: str) -> String {
        let mut result = String::new()
        let mut i: usize = 0
        while i < self.len {
            if i + from.len() <= self.len and self.as_str()[i..(i + from.len())] == from {
                result.push_str(to)
                i = i + from.len()
            } else {
                result.push(self.as_str()[i])
                i = i + 1
            }
        }
        result
    }

    /// Returns a substring of this string.
    pub fn substring(&self, start: usize, end: usize) -> String {
        if start > end or end > self.len {
            String::new()
        } else {
            String::from(self.as_str()[start..end])
        }
    }

    /// Returns a string slice with leading and trailing whitespace removed.
    pub fn trim(&self) -> str {
        self.trim_start().trim_end()
    }

    /// Returns a string slice with leading whitespace removed.
    pub fn trim_start(&self) -> str {
        let mut start: usize = 0
        while start < self.len and self.as_str()[start].is_whitespace() {
            start = start + 1
        }
        self.as_str()[start..self.len]
    }

    /// Returns a string slice with trailing whitespace removed.
    pub fn trim_end(&self) -> str {
        let mut end: usize = self.len
        while end > 0 and self.as_str()[end - 1].is_whitespace() {
            end = end - 1
        }
        self.as_str()[0..end]
    }

    /// Converts the string to uppercase.
    pub fn to_uppercase(&self) -> String {
        let mut result = String::with_capacity(self.len)
        for ch in self.chars() {
            result.push(ch.to_uppercase())
        }
        result
    }

    /// Converts the string to lowercase.
    pub fn to_lowercase(&self) -> String {
        let mut result = String::with_capacity(self.len)
        for ch in self.chars() {
            result.push(ch.to_lowercase())
        }
        result
    }

    /// Splits the string by the given delimiter.
    pub fn split(&self, delimiter: str) -> List<String> {
        let mut result: List<String> = List::new()
        let mut start: usize = 0
        let mut i: usize = 0

        while i <= self.len - delimiter.len() {
            if self.as_str()[i..(i + delimiter.len())] == delimiter {
                result.push(self.substring(start, i))
                start = i + delimiter.len()
                i = start
            } else {
                i = i + 1
            }
        }
        result.push(self.substring(start, self.len))
        result
    }

    /// Splits the string by whitespace.
    pub fn split_whitespace(&self) -> List<String> {
        let mut result: List<String> = List::new()
        let mut current = String::new()

        for ch in self.chars() {
            if ch.is_whitespace() {
                if not current.is_empty() {
                    result.push(current)
                    current = String::new()
                }
            } else {
                current.push(ch)
            }
        }
        if not current.is_empty() {
            result.push(current)
        }
        result
    }

    /// Returns an iterator over the characters of the string.
    pub fn chars(&self) -> Chars {
        Chars { data: self.as_str(), pos: 0 }
    }

    /// Returns an iterator over the bytes of the string.
    pub fn bytes(&self) -> Bytes {
        Bytes { data: &self.data, pos: 0 }
    }

    /// Returns an iterator over the lines of the string.
    pub fn lines(&self) -> Lines {
        Lines { remaining: self.as_str() }
    }

    /// Repeats the string n times.
    pub fn repeat(&self, n: usize) -> String {
        let mut result = String::with_capacity(self.len * n)
        for _ in 0..n {
            result.push_str(self.as_str())
        }
        result
    }
}

/// Iterator over the characters of a string.
pub struct Chars {
    data: str,
    pos: usize
}

impl Iterator for Chars {
    type Item = char

    fn next(&mut self) -> Option<char> {
        if self.pos >= self.data.len() {
            None
        } else {
            let ch = self.data.char_at(self.pos)
            self.pos = self.pos + ch.len_utf8()
            Some(ch)
        }
    }
}

/// Iterator over the bytes of a string.
pub struct Bytes {
    data: &[u8],
    pos: usize
}

impl Iterator for Bytes {
    type Item = u8

    fn next(&mut self) -> Option<u8> {
        if self.pos >= self.data.len() {
            None
        } else {
            let byte = self.data[self.pos]
            self.pos = self.pos + 1
            Some(byte)
        }
    }
}

/// Iterator over the lines of a string.
pub struct Lines {
    remaining: str
}

impl Iterator for Lines {
    type Item = str

    fn next(&mut self) -> Option<str> {
        if self.remaining.is_empty() {
            None
        } else {
            match self.remaining.find('\n') {
                Some(idx) => {
                    let line = self.remaining[0..idx]
                    self.remaining = self.remaining[(idx + 1)..]
                    // Handle CRLF
                    if line.ends_with('\r') {
                        Some(line[0..(line.len() - 1)])
                    } else {
                        Some(line)
                    }
                },
                None => {
                    let line = self.remaining
                    self.remaining = ""
                    Some(line)
                }
            }
        }
    }
}

impl Clone for String {
    fn clone(&self) -> String {
        String::from(self.as_str())
    }
}

impl Eq for String {
    fn eq(&self, other: &String) -> bool {
        self.as_str() == other.as_str()
    }
}

impl Ord for String {
    fn cmp(&self, other: &String) -> Ordering {
        self.as_str().cmp(other.as_str())
    }
}

impl Display for String {
    fn display(&self) -> String {
        self.clone()
    }
}

impl Debug for String {
    fn debug(&self) -> String {
        "\"" + self.as_str() + "\""
    }
}

impl Default for String {
    fn default() -> String {
        String::new()
    }
}

impl Hash for String {
    fn hash(&self, hasher: &mut Hasher) {
        for byte in self.bytes() {
            hasher.write_u8(byte)
        }
    }
}

// String concatenation operator
impl Add<String> for String {
    type Output = String

    fn add(self, other: String) -> String {
        self.concat(&other)
    }
}

impl Add<str> for String {
    type Output = String

    fn add(self, other: str) -> String {
        let mut result = self.clone()
        result.push_str(other)
        result
    }
}
